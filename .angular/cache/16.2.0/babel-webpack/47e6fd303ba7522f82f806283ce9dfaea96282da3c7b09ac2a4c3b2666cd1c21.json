{"ast":null,"code":"import * as i0 from '@angular/core';\nimport { EventEmitter, Injectable, Pipe, Directive, Input, Output, NgModule } from '@angular/core';\nimport { CommonModule } from '@angular/common';\nlet AngularPaginatorService = /*#__PURE__*/(() => {\n  var _class;\n  class AngularPaginatorService {\n    constructor() {\n      /** instances is the collection of pagination componetns */\n      this.instances = {};\n      /** emits an event with instance id whenever the page number changes */\n      this.change = new EventEmitter();\n    }\n    /** id is used to identify pagination instances */\n\n    /**\n     * creates an instance for every pipe differentiated with id\n     *\n     * @param instance each instance refers to a unique pagination component\n     */\n    registerInstance(instance) {\n      if (!this.instances[instance.id]) {\n        this.instances[instance.id] = instance;\n        this.change.emit(instance.id);\n      } else {\n        const changed = this.updateInstance(instance);\n        if (changed) {\n          this.change.emit(instance.id);\n        }\n      }\n    }\n    /**\n     * updates existing pagination instances available\n     * and returns true if value has changed\n     *\n     * @param instance an unique pagination component\n     */\n    updateInstance(instance) {\n      let updated = false;\n      const currentInstance = this.instances[instance.id];\n      for (const [k, v] of Object.entries(instance)) {\n        const key = k;\n        if (key !== 'id' && currentInstance[k] !== v && !updated) {\n          this.instances[instance.id] = {\n            ...instance,\n            id: instance.id\n          };\n          updated = true;\n        }\n      }\n      return updated;\n    }\n    /**\n     * return instance with given id\n     *\n     * @param id unique id of the pagination component\n     */\n    getInstance(id) {\n      return this.instances[id];\n    }\n    /**\n     * return currentPage for given id\n     *\n     * @param id unique id of the pagination component\n     */\n    getCurrentPage(id) {\n      return this.instances[id].currentPage;\n    }\n  }\n  _class = AngularPaginatorService;\n  _class.id = 'ANGULAR_PAGINATOR_DEFAULT';\n  _class.ɵfac = function _class_Factory(t) {\n    return new (t || _class)();\n  };\n  _class.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n    token: _class,\n    factory: _class.ɵfac\n  });\n  return AngularPaginatorService;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n/**\n * Pagination Pipe which paginates the array for the provided arguments such as `itemsPerPage` and `currentPage`\n */\nlet AngularPaginatorPipe = /*#__PURE__*/(() => {\n  var _class2;\n  class AngularPaginatorPipe {\n    /**\n     *\n     * @param angularPaginatorService service for angular pagiantor\n     */\n    constructor(angularPaginatorService) {\n      this.angularPaginatorService = angularPaginatorService;\n    }\n    /**\n     * this pipes paginates the array for the provided arguments such as `itemsPerPage` and `currentPage`\n     *\n     * @param array input array for which the manipulation happens\n     * @param args input arguments for the paginator pipe\n     */\n    transform(array, args) {\n      const instance = this.createInstance(array, args);\n      // create pagination information\n      this.angularPaginatorService.registerInstance(instance);\n      // set the slicing range\n      const start = (instance.currentPage - 1) * instance.itemsPerPage;\n      const end = instance.currentPage * instance.itemsPerPage;\n      return array.slice(start, end);\n    }\n    /**\n     * create an instance for each pipe\n     *\n     * @param array input array for which the manipulation happens\n     * @param args input arguments for the paginator pipe\n     */\n    createInstance(array, args) {\n      return {\n        id: args?.id ? args.id : AngularPaginatorService.id,\n        currentPage: args?.currentPage ? args.currentPage : 1,\n        itemsPerPage: args?.itemsPerPage ? args.itemsPerPage : 10,\n        totalItems: array.length\n      };\n    }\n  }\n  _class2 = AngularPaginatorPipe;\n  _class2.ɵfac = function _class2_Factory(t) {\n    return new (t || _class2)(i0.ɵɵdirectiveInject(AngularPaginatorService, 16));\n  };\n  _class2.ɵpipe = /* @__PURE__ */i0.ɵɵdefinePipe({\n    name: \"angularPaginator\",\n    type: _class2,\n    pure: true\n  });\n  return AngularPaginatorPipe;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n/**\n * This is the directive where the actual pagination takes place, it provides a sync between the\n * pipes and the pagination component\n */\nlet AngularPaginatorDirective = /*#__PURE__*/(() => {\n  var _class3;\n  class AngularPaginatorDirective {\n    /**\n     *\n     * @param angularPaginatorService serivce for angular paginator\n     */\n    constructor(angularPaginatorService) {\n      this.angularPaginatorService = angularPaginatorService;\n      /**\n       * Use unique id when multiple paginations are being used on the same page.\n       * By Default Paginator uses id `ANGULAR_PAGINATOR_DEFAULT`\n       */\n      this.id = AngularPaginatorService.id;\n      /**\n       * Whether to keep current page in the middle of the visible ones\n       */\n      this.rotate = false;\n      /**\n       * Whether to always display the first and last page numbers.\n       * If max-size is smaller than the number of pages, then the first and last page numbers are still shown with ellipses\n       * in-between as necessary. NOTE: max-size refers to the center of the range.\n       * This option may add up to 2 more numbers on each side of the displayed range for the end value and\n       * what would be an ellipsis but is replaced by a number because it is sequential\n       */\n      this.boundaryLinkNumbers = false;\n      /**\n       * Also displays ellipses when rotate is true and maxSize is smaller than the number of pages forceEllipses\n       */\n      this.forceEllipses = false;\n      this.firstPage = 1;\n      this.pages = [];\n      /**\n       * Emits an event whenever the current page is changed, It emits the current page number\n       */\n      this.pageChange = new EventEmitter(true);\n      // subscribe to changes\n      this.subscription = this.angularPaginatorService.change.subscribe(id => {\n        if (id === this.id) {\n          this.updatePages();\n        }\n      });\n    }\n    /**\n     * Navigate to prevoius page\n     */\n    toPreviousPage() {\n      if (this.currentPage > this.firstPage) {\n        this.setPage(this.currentPage - 1);\n      }\n    }\n    /**\n     * Navigate to next page\n     */\n    toNextPage() {\n      if (this.currentPage < this.lastPage) {\n        this.setPage(this.currentPage + 1);\n      }\n    }\n    /**\n     * Navigate to first page\n     */\n    toFirstPage() {\n      this.setPage(this.firstPage);\n    }\n    /**\n     * Navigate to last page\n     */\n    toLastPage() {\n      this.setPage(this.lastPage);\n    }\n    /**\n     * Sets current page\n     *\n     * @param page page number to set as currentPage\n     */\n    setCurrentPage(page) {\n      this.setPage(page);\n    }\n    /**\n     *\n     * @param page  page number to set\n     */\n    setPage(page) {\n      if (page && this.currentPage !== page) {\n        this.currentPage = page;\n        this.pageChange.emit(page);\n      }\n    }\n    /**\n     * create page object used for template\n     *\n     * @param pageNumber page number\n     * @param text page number, text to be displayed\n     * @param isActive whether the page is active or not, true for currentPage\n     */\n    makePage(pageNumber, text, isActive) {\n      return {\n        number: pageNumber,\n        text,\n        active: isActive\n      };\n    }\n    /**\n     *  computes the page limit\n     *\n     * @param currentPage current page number\n     * @param itemsPerPage total items per page\n     * @param totalItems no of items for pagination, usually array length\n     */\n    computePageLimits(currentPage, totalItems, itemsPerPage) {\n      const totalPages = Math.ceil(totalItems / itemsPerPage);\n      // Default page limits\n      let startPage = 1;\n      let endPage = totalPages;\n      const isMaxSized = this.maxSize ? this.maxSize < totalPages : false;\n      // recompute if maxSize\n      if (isMaxSized && this.maxSize) {\n        if (this.rotate) {\n          // current page is displayed in the middle of the visible ones\n          startPage = Math.max(currentPage - Math.floor(this.maxSize / 2), 1);\n          endPage = startPage + this.maxSize - 1;\n          // Adjust if limit is exceeded\n          if (endPage > totalPages) {\n            endPage = totalPages;\n            startPage = endPage - this.maxSize + 1;\n          }\n        } else {\n          // Visible pages are paginated with maxSize\n          startPage = (Math.ceil(currentPage / this.maxSize) - 1) * this.maxSize + 1;\n          // adjust last page if limit is exceeded\n          endPage = Math.min(startPage + this.maxSize - 1, totalPages);\n        }\n      }\n      return {\n        startPage,\n        endPage,\n        totalPages,\n        isMaxSized\n      };\n    }\n    /**\n     *  create page array\n     *\n     * @param currentPage current page number\n     * @param itemsPerPage total items per page\n     * @param totalItems no of items for pagination, usually array length\n     */\n    getPages(currentPage, itemsPerPage, totalItems) {\n      const pages = [];\n      const pageLimits = this.computePageLimits(currentPage, totalItems, itemsPerPage);\n      const {\n        startPage,\n        endPage,\n        totalPages,\n        isMaxSized\n      } = pageLimits;\n      this.lastPage = totalPages;\n      // add page number links\n      for (let pageNumber = startPage; pageNumber <= endPage; pageNumber += 1) {\n        const page = this.makePage(pageNumber, pageNumber.toString(), pageNumber === currentPage);\n        pages.push(page);\n      }\n      // add links to move between page sets\n      if (isMaxSized && this.maxSize && this.maxSize > 0 && (!this.rotate || this.forceEllipses || this.boundaryLinkNumbers)) {\n        if (startPage > 1) {\n          // need ellipsis for all options unless range is too close to beginning\n          if (!this.boundaryLinkNumbers || startPage > 3) {\n            const previousPageSet = this.makePage(startPage - 1, '...', false);\n            pages.unshift(previousPageSet);\n          }\n          if (this.boundaryLinkNumbers) {\n            if (startPage === 3) {\n              // need to replace ellipsis when the buttons would be sequential\n              const secondPageLink = this.makePage(2, '2', false);\n              pages.unshift(secondPageLink);\n            }\n            // add the first page\n            const firstPageLink = this.makePage(1, '1', false);\n            pages.unshift(firstPageLink);\n          }\n        }\n        if (endPage < totalPages) {\n          // need ellipsis for all options unless range is too close to end\n          if (!this.boundaryLinkNumbers || endPage < totalPages - 2) {\n            const nextPageSet = this.makePage(endPage + 1, '...', false);\n            pages.push(nextPageSet);\n          }\n          if (this.boundaryLinkNumbers) {\n            // need to replace ellipsis when the buttons would be sequential\n            if (endPage === totalPages - 2) {\n              const secondToLastPageLink = this.makePage(totalPages - 1, (totalPages - 1).toString(), false);\n              pages.push(secondToLastPageLink);\n            }\n            // add the last page\n            const lastPageLink = this.makePage(totalPages, totalPages.toString(), false);\n            pages.push(lastPageLink);\n          }\n        }\n      }\n      return pages;\n    }\n    /**\n     * Updates the pagination component\n     */\n    updatePages() {\n      const instance = this.angularPaginatorService.getInstance(this.id);\n      const correctedCurrentPage = this.outOfBoundCorrection(instance);\n      if (correctedCurrentPage !== instance.currentPage || this.currentPage !== instance.currentPage) {\n        this.setPage(correctedCurrentPage);\n      }\n      this.pages = this.getPages(instance.currentPage, instance.itemsPerPage, instance.totalItems);\n    }\n    /**\n     * Check if currentPage is out of bound with totalPages\n     *\n     * @param instance instance for which the range is to be corrected\n     */\n    outOfBoundCorrection(instance) {\n      const totalPages = Math.ceil(instance.totalItems / instance.itemsPerPage);\n      if (totalPages < instance.currentPage && totalPages > 0) {\n        return totalPages;\n      } else if (instance.currentPage < 1) {\n        return 1;\n      }\n      return instance.currentPage;\n    }\n    /**\n     * check if there is any instance registered with the id\n     */\n    isValidId() {\n      if (!this.angularPaginatorService.getInstance(this.id)) {\n        throw new Error(`There is no instance registered with id \\`${this.id}\\``);\n      }\n    }\n    ngOnInit() {\n      this.isValidId();\n      this.updatePages();\n    }\n    ngOnDestroy() {\n      /** destroy the subscription when the directive is destroyed */\n      this.subscription.unsubscribe();\n    }\n  }\n  _class3 = AngularPaginatorDirective;\n  _class3.ɵfac = function _class3_Factory(t) {\n    return new (t || _class3)(i0.ɵɵdirectiveInject(AngularPaginatorService));\n  };\n  _class3.ɵdir = /* @__PURE__ */i0.ɵɵdefineDirective({\n    type: _class3,\n    selectors: [[\"angularPaginator\"], [\"\", \"angularPaginator\", \"\"]],\n    inputs: {\n      id: \"id\",\n      maxSize: \"maxSize\",\n      rotate: \"rotate\",\n      boundaryLinkNumbers: \"boundaryLinkNumbers\",\n      forceEllipses: \"forceEllipses\"\n    },\n    outputs: {\n      pageChange: \"pageChange\"\n    },\n    exportAs: [\"angularPaginator\"]\n  });\n  return AngularPaginatorDirective;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nlet AngularPaginatorModule = /*#__PURE__*/(() => {\n  var _class4;\n  class AngularPaginatorModule {}\n  _class4 = AngularPaginatorModule;\n  _class4.ɵfac = function _class4_Factory(t) {\n    return new (t || _class4)();\n  };\n  _class4.ɵmod = /* @__PURE__ */i0.ɵɵdefineNgModule({\n    type: _class4\n  });\n  _class4.ɵinj = /* @__PURE__ */i0.ɵɵdefineInjector({\n    providers: [AngularPaginatorService],\n    imports: [CommonModule]\n  });\n  return AngularPaginatorModule;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n/*\n * Public API Surface of angular-paginator\n */\n\n/**\n * Generated bundle index. Do not edit.\n */\n\nexport { AngularPaginatorDirective, AngularPaginatorModule, AngularPaginatorPipe };\n//# sourceMappingURL=angular-paginator.mjs.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}